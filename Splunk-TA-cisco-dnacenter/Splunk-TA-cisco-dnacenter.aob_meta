{"basic_builder": {"appname": "Splunk-TA-cisco-dnacenter", "friendly_name": "Cisco DNA Center Add-on", "version": "1.0.0", "author": "Cisco Systems", "description": "Cisco DNA Center Add-on for Splunk", "theme": "#ffffff", "large_icon": "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", "small_icon": "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", "visible": true, "tab_version": "4.1.0", "tab_build_no": "0", "build_no": 1}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "cisco:dnac:fabricsite", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "cisco_dnac_fabricsite", "title": "cisco_dnac_fabricsite", "description": "", "type": "customized", "parameters": [{"required": true, "name": "cisco_dna_center_host", "label": "Cisco DNA Center Host", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": ""}, {"required": true, "name": "cisco_dna_center_account", "label": "Cisco DNA Center Account", "default_value": "", "placeholder": "", "help_string": "", "possible_values": [], "type": "global_account", "format_type": "global_account", "value": ""}], "data_inputs_options": [{"type": "customized_var", "name": "cisco_dna_center_host", "title": "Cisco DNA Center Host", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "cisco_dna_center_account", "title": "Cisco DNA Center Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport datetime\nimport json\nimport os\nimport sys\nimport time\n\nimport cisco_dnac_api as api\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef simplify_site(site_resp):\n    \"\"\"\n    This function will simplify the site data for Splunk searches\n    :param site_resp: Cisco DNAC SDK api\n    :return: new site response\n    \"\"\"\n    simplified_site = {}\n    if site_resp:\n        simplified_site['SiteName'] = site_resp.get('name')\n        simplified_site['SiteNameHierarchy'] = site_resp.get('siteNameHierarchy')\n        simplified_site['SiteType'] = 'area'\n        if site_resp.get('additionalInfo'):\n            if len(site_resp['additionalInfo']) > 0:\n                for additional_info in site_resp['additionalInfo']:\n                    if isinstance(additional_info, dict) and additional_info.get('attributes'):\n                        if isinstance(additional_info['attributes'], dict) and additional_info['attributes'].get('type'):\n                            simplified_site['SiteType'] = additional_info['attributes'].get('type')\n        return simplified_site\n    else:\n        return {}\n\ndef simplify_sites(dnac, sites_response, seen):\n    \"\"\"\n    This function will filter and simplify the sites data for Splunk searches\n    :param dnac: Cisco DNAC SDK api\n    :param sites_response: Cisco DNAC SDK api\n    :param seen: set to filter previous SiteNameHierarchy values\n    :return: new sites response\n    \"\"\"\n    fabric_sites_response = []\n    for site_response in sites_response:\n        site = simplify_site(site_response)\n        site_key = site['SiteNameHierarchy']\n        # if it was seen before, skip it\n        if site_key in seen:\n            continue\n        # if not added\n        seen.add(site_key)\n        fabric_site = get_simplified_fabric_site(dnac, site_key)\n        fabric_site_new = dict(site)\n        if fabric_site:\n            fabric_site_new.update({'HasFabric': 'True'})\n        else:\n            fabric_site_new.update({'HasFabric': 'False'})\n        fabric_site_new.update(fabric_site)\n        fabric_sites_response.append(fabric_site_new)\n    return fabric_sites_response\n\ndef get_simplified_sites(dnac):\n    \"\"\"\n    This function will retrieve the sites and simplify them\n    :param dnac: Cisco DNAC SDK api\n    :return: sites response\n    \"\"\"\n    limit = 20\n    offset = 1\n    sites_responses = []\n    do_request_next = True\n    seen = set()\n    while do_request_next:\n        try:\n            sites_response = dnac.sites.get_site(limit=str(limit), offset=str(offset))\n            if sites_response and sites_response.response:\n                sites_responses.extend(simplify_sites(dnac, sites_response.response, seen))\n                if len(sites_response.response) < limit:\n                    do_request_next = False\n                    break\n            else:\n                do_request_next = False\n                break\n        except Exception:\n            do_request_next = False\n            break\n        offset = offset + limit\n    return sites_responses\n\ndef get_simplified_fabric_site(dnac, site_name_hierarchy):\n    \"\"\"\n    This function will retrieve the fabric site and simplify them\n    :param dnac: Cisco DNAC SDK api\n    :param site_name_hierarchy: site name hierarchy\n    :return: fabric site response\n    \"\"\"\n    response = {}\n    try:\n        fabric_site = dnac.sda.get_site(site_name_hierarchy)\n        if fabric_site.get('status') == 'success':\n            response['FabricSiteNameHierarchy'] = fabric_site.get('siteNameHierarchy') or ''\n            response['FabricName'] = fabric_site.get('fabricName') or ''\n            response['FabricType'] = fabric_site.get('fabricType') or ''\n            response['FabricDomainType'] = fabric_site.get('fabricDomainType') or ''\n        return response\n    except Exception:\n        return response\n\ndef is_different(state, item):\n    if not isinstance(state, dict):\n        return True\n    if not isinstance(item, dict):\n        return True\n    keys = set(state.keys())\n    keys = keys.union(set(item.keys()))\n    properties = list(keys)\n    for property in properties:\n        if state.get(property) != item.get(property):\n            return True\n    return False\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    cisco_dna_center_host = definition.parameters.get('cisco_dna_center_host', None)\n    cisco_dna_center_account = definition.parameters.get('cisco_dna_center_account', None)\n    pass\n\ndef collect_events(helper, ew):\n    opt_cisco_dna_center_host = helper.get_arg('cisco_dna_center_host')\n    opt_cisco_dna_center_account = helper.get_arg('cisco_dna_center_account')\n\n    account_username = opt_cisco_dna_center_account.get(\"username\", None)\n    account_password = opt_cisco_dna_center_account.get(\"password\", None)\n    account_name = opt_cisco_dna_center_account.get(\"name\", None)\n    current_version = \"2.2.3.3\"\n    current_verify = False\n    current_debug = False\n\n    dnac = api.DNACenterAPI(\n        username=account_username,\n        password=account_password,\n        base_url=opt_cisco_dna_center_host,\n        version=current_version,\n        verify=current_verify,\n        debug=current_debug)\n\n    r_json = []\n\n    # get the sites and fabric sites associated with them\n    simplified_sites = get_simplified_sites(dnac)\n\n    for item in simplified_sites:\n        key = \"{0}_{1}\".format(opt_cisco_dna_center_host, item['SiteNameHierarchy'])\n        state = helper.get_check_point(key)\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        if state is None:\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        elif is_different(state, item):\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        # helper.delete_check_point(key)\n\n    # To create a splunk event\n    event = helper.new_event(json.dumps(r_json), time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    ew.write_event(event)\n", "customized_options": [{"name": "cisco_dna_center_host", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "value": "account0"}], "uuid": "ed7611425ed44563bc739621b9e3a729"}, {"index": "default", "sourcetype": "cisco:dnac:clienthealth", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "cisco_dnac_clienthealth", "title": "cisco_dnac_clienthealth", "description": "", "type": "customized", "parameters": [{"required": true, "name": "cisco_dna_center_host", "label": "Cisco DNA Center Host", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": "https://sandboxdnac.cisco.com"}, {"required": true, "name": "cisco_dna_center_account", "label": "Cisco DNA Center Account", "default_value": "", "placeholder": "", "help_string": "", "possible_values": [], "type": "global_account", "format_type": "global_account", "value": "account0"}], "data_inputs_options": [{"type": "customized_var", "name": "cisco_dna_center_host", "title": "Cisco DNA Center Host", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "cisco_dna_center_account", "title": "Cisco DNA Center Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport json\nimport sys\nimport time\nimport datetime\n\nimport cisco_dnac_api as api\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef get_epoch_current_time():\n    \"\"\"\n    This function will return the epoch time for the {timestamp}\n    :return: epoch time including msec\n    \"\"\"\n    epoch = time.time()*1000\n    return \"{0}\".format(int(epoch))\n\ndef get_client_health(dnac):\n    \"\"\"\n    This function will retrieve the client health at the time the function is called\n    :param dnac: Cisco DNAC SDK api\n    :return: client health response\n    \"\"\"\n    epoch_time = get_epoch_current_time()\n    health_response = dnac.clients.get_overall_client_health(timestamp=epoch_time)\n    return health_response\n\ndef filter_health_data(network_health_response):\n    \"\"\"\n    This function will filter data to get the overall client data.\n    :param network_health_response: network health data\n    :return: health distribution summary response\n    \"\"\"\n    health_distribution = []\n\n    for response_item in network_health_response.response:\n        # Set siteId\n        for score_item in response_item['scoreDetail']:\n            health_item = {}\n            # Set default data\n            health_item['siteId'] = response_item['siteId']\n            health_item['clientType'] = score_item.scoreCategory.value\n            health_item['clientCount'] = score_item.clientCount\n            health_item['clientUniqueCount'] = score_item.clientUniqueCount\n            health_item['scoreValue'] = score_item.scoreValue\n            health_item['starttime'] = score_item.starttime\n            health_item['endtime'] = score_item.endtime\n            health_item['scoreType'] = \"ALL\"\n\n            # If it is ALL skip, nothing more to do\n            if score_item.scoreCategory.value == \"ALL\":\n                health_distribution.append(health_item)\n                continue\n\n            if score_item.scoreList:\n                # Set artificial scoreType for general client\n                health_distribution.append(health_item)\n                for score_type in score_item.scoreList:\n                    health_item_new = dict(health_item)\n                    health_item_new['scoreType'] = score_type.scoreCategory.value\n                    health_item_new['clientCount'] = score_type.clientCount\n                    health_item_new['clientUniqueCount'] = score_type.clientUniqueCount\n                    health_item_new['scoreValue'] = score_type.scoreValue\n                    health_item_new['starttime'] = score_type.starttime\n                    health_item_new['endtime'] = score_type.endtime\n                    health_distribution.append(health_item_new)\n    return health_distribution\n\n\ndef is_different(state, item):\n    if not isinstance(state, dict):\n        return True\n    if not isinstance(item, dict):\n        return True\n    keys = set(state.keys())\n    keys = keys.union(set(item.keys()))\n    properties = list(keys)\n    for property_ in properties:\n        if state.get(property_) != item.get(property_):\n            return True\n    return False\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    cisco_dna_center_host = definition.parameters.get('cisco_dna_center_host', None)\n    cisco_dna_center_account = definition.parameters.get('cisco_dna_center_account', None)\n    pass\n\ndef collect_events(helper, ew):\n    opt_cisco_dna_center_host = helper.get_arg('cisco_dna_center_host')\n    opt_cisco_dna_center_account = helper.get_arg('cisco_dna_center_account')\n\n    account_username = opt_cisco_dna_center_account.get(\"username\", None)\n    account_password = opt_cisco_dna_center_account.get(\"password\", None)\n    account_name = opt_cisco_dna_center_account.get(\"name\", None)\n    current_version = \"2.2.3.3\"\n    current_verify = False\n    current_debug = False\n\n    dnac = api.DNACenterAPI(\n        username=account_username,\n        password=account_password,\n        base_url=opt_cisco_dna_center_host,\n        version=current_version,\n        verify=current_verify,\n        debug=current_debug)\n\n    r_json = []\n    # get the overall client health\n    overall_client_health = get_client_health(dnac)\n    # simplify gathered information\n    response = filter_health_data(overall_client_health)\n\n    for item in response:\n        key = \"{0}_{1}_{2}_{3}\".format(opt_cisco_dna_center_host, item.get('siteId') or \"NA\", item.get('clientType') or \"NA\", item.get('scoreType') or \"NA\")\n        state = helper.get_check_point(key)\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        if state is None:\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        elif is_different(state, item):\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        # helper.delete_check_point(key)\n\n    # To create a splunk event\n    event = helper.new_event(json.dumps(r_json), time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    ew.write_event(event)\n", "customized_options": [{"name": "cisco_dna_center_host", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "value": "account0"}], "uuid": "f6d3ae9aef804f8fa2a24abd56612cee", "sample_count": "20"}, {"index": "default", "sourcetype": "cisco:dnac:devicehealth", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "cisco_dnac_devicehealth", "title": "cisco_dnac_devicehealth", "description": "", "type": "customized", "parameters": [{"required": true, "name": "cisco_dna_center_host", "label": "Cisco DNA Center Host", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": "https://sandboxdnac.cisco.com"}, {"required": true, "name": "cisco_dna_center_account", "label": "Cisco DNA Center Account", "default_value": "", "placeholder": "", "help_string": "", "possible_values": [], "type": "global_account", "format_type": "global_account", "value": "account0"}], "data_inputs_options": [{"type": "customized_var", "name": "cisco_dna_center_host", "title": "Cisco DNA Center Host", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "cisco_dna_center_account", "title": "Cisco DNA Center Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport json\nimport sys\nimport time\nimport datetime\n\nimport cisco_dnac_api as api\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef get_epoch_current_previous_times(interval_seconds):\n    \"\"\"\n    This function will return the epoch time for the {timestamp} and a previous epoch time\n    :return: epoch time (now) including msec, epoch time (previous) including msec\n    \"\"\"\n    # REVIEW: It is recommended that this time matches the Splunk's data input interval\n    now = datetime.datetime.now()\n    rounded = now - datetime.timedelta(\n        minutes=now.minute,\n        seconds=now.second % interval_seconds + interval_seconds if interval_seconds > 0 else now.second,\n        microseconds=now.microsecond)\n    return (int(now.timestamp() * 1000), int(rounded.timestamp() * 1000))\n\ndef get_device_health(dnac, input_interval):\n    \"\"\"\n    This function will retrieve the device health from a previous time to the time the function is called\n    :param dnac: Cisco DNAC SDK api\n    :param input_interval: interval in seconds\n    :return: device health response\n    \"\"\"\n    (epoch_current_time, epoch_previous_time) = get_epoch_current_previous_times(input_interval)\n    limit = 20\n    offset = 1\n    devices_responses = []\n    do_request_next = True\n    while do_request_next:\n        try:\n            health_response = dnac.devices.devices(start_time=epoch_previous_time, end_time=epoch_current_time, limit=limit, offset=offset)\n            if health_response and health_response.response:\n                devices_responses.extend(health_response.response)\n                if len(health_response.response) < limit:\n                    do_request_next = False\n                    break\n            else:\n                do_request_next = False\n                break\n        except Exception:\n            do_request_next = False\n            break\n        offset = offset + limit\n    return devices_responses\n\ndef get_devices(dnac):\n    \"\"\"\n    This function will retrieve the devices\n    :param dnac: Cisco DNAC SDK api\n    :return: devices response\n    \"\"\"\n    limit = 20\n    offset = 1\n    devices_responses = []\n    do_request_next = True\n    while do_request_next:\n        try:\n            device_response = dnac.devices.get_device_list(limit=limit, offset=offset)\n            if device_response and device_response.response:\n                devices_responses.extend(device_response.response)\n                if len(device_response.response) < limit:\n                    do_request_next = False\n                    break\n            else:\n                do_request_next = False\n                break\n        except Exception:\n            do_request_next = False\n            break\n        offset = offset + limit\n    return devices_responses\n\ndef get_important_device_values(device_item):\n    \"\"\"\n    This function will simplify the device data for Splunk searches\n    :param device_item: device data\n    :return: new device response\n    \"\"\"\n    response = {}\n    response['DeviceName'] = device_item.get('hostname') or 'NA'\n    response['IpAddress'] = device_item.get('managementIpAddress') or device_item.get('ipAddress') or ''\n    response['DeviceFamily'] = device_item.get('family') or ''\n    response['Reachability'] = device_item.get('reachabilityStatus') or ''\n    response['ReachabilityFailureReason'] = device_item.get('reachabilityFailureReason') or ''\n    # Section to set the value of Manageability and ManageErrors\n    response['ManageErrors'] = ''\n    if device_item.get('managementState') == \"Managed\":\n        response['Manageability'] = \"Managed\"\n        if device_item.get('collectionStatus') and device_item['collectionStatus'] != \"Managed\":\n            response['Manageability'] = \"Managed (With Errors)\"\n            response['ManageErrors'] = device_item['collectionStatus']\n    elif device_item.get('managementState') in [\"Unmanaged\", \"Never Managed\"]:\n        response['Manageability'] = \"Unmanaged\"\n    else:\n        response['Manageability'] = \"Managed (With Errors)\"\n    response['MACAddress'] = device_item.get('macAddress') or device_item.get('apEthernetMacAddress') or ''\n    response['DeviceRole'] = device_item.get('role') or 'UNKNOWN'\n    response['ImageVersion'] = device_item.get('softwareVersion') or ''\n    response['Uptime'] = device_item.get('upTime') or ''\n    if device_item.get('uptimeSeconds') is not None:\n        response['UptimeSeconds'] = device_item.get('uptimeSeconds')\n    else:\n        response['UptimeSeconds'] = 0\n    response['LastUpdated'] = device_item.get('lastUpdated') or ''\n    if device_item.get('lastUpdateTime') is not None:\n        response['LastUpdateTime'] = device_item.get('lastUpdateTime')\n    else:\n        response['LastUpdateTime'] = 0\n    response['SerialNumber'] = device_item.get('serialNumber') or ''\n    response['DeviceSeries'] = device_item.get('series') or ''\n    response['Platform'] = device_item.get('platformId') or ''\n    response['SupportType'] = device_item.get('deviceSupportLevel') or ''\n    response['AssociatedWLCIP'] = device_item.get('associatedWlcIp') or ''\n    return response\n\ndef get_health_device_values(health_device):\n    \"\"\"\n    This function will simplify the health device data for Splunk searches\n    :param health_device: health device data\n    :return: new health device response\n    \"\"\"\n    response = {'HasHealthReport': 'True'}\n    if health_device.get('overallHealth') is not None:\n        response['OverallHealth'] = health_device.get('overallHealth')\n    else:\n        response['OverallHealth'] = 0\n    response['HealthScore'] = response['OverallHealth']\n    response['IssueCount'] = health_device.get('issueCount') or 0\n    response['Site'] = health_device.get('location') or ''\n    response['Location'] = health_device.get('location') or ''\n\n    response['InterfaceLinkErrHealth'] = health_device.get('interfaceLinkErrHealth') or 0\n    response['CPUUtilization'] = health_device.get('cpuUlitilization') or health_device.get('cpuUtilization') or 0\n    response['CPUHealth'] = health_device.get('cpuHealth') or 0\n    response['MemoryUtilizationHealth'] = health_device.get('memoryUtilizationHealth') or 0\n    response['MemoryUtilization'] = health_device.get('memoryUtilization') or 0\n    response['InterDeviceLinkAvailHealth'] = health_device.get('interDeviceLinkAvailHealth') or 0\n\n    client_count = health_device.get('clientCount') or {}\n    response['HasClientCount'] = str(len(client_count) > 0)\n    response['ClientCountRadio0'] = client_count.get('radio0') or 0\n    response['ClientCountRadio1'] = client_count.get('radio1') or 0\n    response['ClientCountGhz24'] =  client_count.get('Ghz24') or 0\n    response['ClientCountGhz50'] =  client_count.get('Ghz50') or 0\n\n    interference_health = health_device.get('interferenceHealth') or {}\n    response['HasInterferenceHealth'] = str(len(interference_health) > 0)\n    response['InterferenceHealthRadio0'] = interference_health.get('radio0') or 0\n    response['InterferenceHealthRadio1'] = interference_health.get('radio1') or 0\n    response['InterferenceHealthGhz24'] =  interference_health.get('Ghz24') or 0\n    response['InterferenceHealthGhz50'] =  interference_health.get('Ghz50') or 0\n\n    noise_health = health_device.get('noiseHealth') or {}\n    response['HasNoiseHealth'] = str(len(noise_health) > 0)\n    response['NoiseHealthRadio1'] = noise_health.get('radio1') or 0\n    response['NoiseHealthGhz50'] =  noise_health.get('Ghz50') or 0\n    # following attribute is not present in documentation\n    response['NoiseHealthRadio0'] = noise_health.get('radio0') or 0\n    # following attribute is not present in documentation\n    response['NoiseHealthGhz24'] =  noise_health.get('Ghz24') or 0\n\n    air_quality_health = health_device.get('airQualityHealth') or {}\n    response['HasAirQualityHealth'] = str(len(air_quality_health) > 0)\n    response['AirQualityHealthRadio0'] = air_quality_health.get('radio0') or 0\n    response['AirQualityHealthRadio1'] = air_quality_health.get('radio1') or 0\n    response['AirQualityHealthGhz24'] =  air_quality_health.get('Ghz24') or 0\n    response['AirQualityHealthGhz50'] =  air_quality_health.get('Ghz50') or 0\n\n    utilization_health = health_device.get('utilizationHealth') or {}\n    response['HasUtilization'] = str(len(utilization_health) > 0)\n    response['UtilizationRadio0'] = utilization_health.get('radio0') or 0\n    response['UtilizationRadio1'] = utilization_health.get('radio1') or 0\n    response['UtilizationGhz24'] =  utilization_health.get('Ghz24') or 0\n    response['UtilizationGhz50'] =  utilization_health.get('Ghz50') or 0\n\n    # NOTE: Properties that are already present\n    # NOTE: WARNING: data maybe have slightly different format\n    # response['DeviceFamily'] = health_device.get('deviceFamily') or ''\n    # response['DeviceSeries'] = health_device.get('deviceType') or health_device.get('model') or ''\n    # response['MACAddress'] = health_device.get('macAddress') or ''\n    # response['DeviceName'] = health_device.get('name') or 'NA'\n    # response['ImageVersion'] = health_device.get('osVersion') or ''\n    # response['IpAddress'] = health_device.get('ipAddress') or ''\n    # response['Reachability'] = health_device.get('reachabilityHealth') or ''\n    return response\n\ndef filter_health_data(health_devices, devices_items):\n    \"\"\"\n    This function will filter data to get the overall device data.\n    :param health_devices: health devices data\n    :param devices_items: devices data\n    :return: health summary response\n    \"\"\"\n    health_summary_response = []\n    device_dict = {}\n    for device_item in devices_items:\n        ip_address_key = device_item.get('managementIpAddress') or device_item.get('ipAddress')\n        device_dict[ip_address_key] = dict(get_important_device_values(device_item))\n    for health_device in health_devices:\n        ip_address_key = health_device.get('ipAddress') or health_device.get('managementIpAddress')\n        if device_dict.get(ip_address_key):\n            device_dict[ip_address_key].update(get_health_device_values(health_device))\n        else:\n            device_dict[ip_address_key].update({'HasHealthReport': 'False'})\n    health_summary_response = list(device_dict.values())\n    return health_summary_response\n\ndef is_different(state, item):\n    if not isinstance(state, dict):\n        return True\n    if not isinstance(item, dict):\n        return True\n    keys = set(state.keys())\n    keys = keys.union(set(item.keys()))\n    properties = list(keys)\n    for property in properties:\n        if state.get(property) != item.get(property):\n            return True\n    return False\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    cisco_dna_center_host = definition.parameters.get('cisco_dna_center_host', None)\n    cisco_dna_center_account = definition.parameters.get('cisco_dna_center_account', None)\n    pass\n\ndef collect_events(helper, ew):\n    opt_cisco_dna_center_host = helper.get_arg('cisco_dna_center_host')\n    opt_cisco_dna_center_account = helper.get_arg('cisco_dna_center_account')\n\n    account_username = opt_cisco_dna_center_account.get(\"username\", None)\n    account_password = opt_cisco_dna_center_account.get(\"password\", None)\n    account_name = opt_cisco_dna_center_account.get(\"name\", None)\n    current_version = \"2.2.3.3\"\n    current_verify = False\n    current_debug = False\n\n    # use default input_interval\n    input_interval = 900\n    try:\n        input_interval = int(helper.get_arg(\"interval\"))\n    except ValueError as e:\n        input_interval = 900\n\n    dnac = api.DNACenterAPI(\n        username=account_username,\n        password=account_password,\n        base_url=opt_cisco_dna_center_host,\n        version=current_version,\n        verify=current_verify,\n        debug=current_debug)\n\n    # get the overall device health\n    health_devices = get_device_health(dnac, input_interval)\n    # get the information of all devices\n    devices_items = get_devices(dnac)\n    # merge and simplify gathered information\n    overall_device_health = filter_health_data(health_devices, devices_items)\n\n    r_json = []\n    for item in overall_device_health:\n        key = \"{0}_{1}\".format(opt_cisco_dna_center_host, item['IpAddress'])\n        state = helper.get_check_point(key)\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        if state is None:\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        elif is_different(state, item):\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        # helper.delete_check_point(key)\n\n    # To create a splunk event\n    event = helper.new_event(json.dumps(r_json), time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    ew.write_event(event)\n", "customized_options": [{"name": "cisco_dna_center_host", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "value": "account0"}], "uuid": "513d26892f964892b59ed13cd1098c5c", "sample_count": "4"}, {"index": "default", "sourcetype": "cisco:dnac:fabricdevice", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "cisco_dnac_fabricdevice", "title": "cisco_dnac_fabricdevice", "description": "", "type": "customized", "parameters": [{"required": true, "name": "cisco_dna_center_host", "label": "Cisco DNA Center Host", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": "https://sandboxdnac.cisco.com"}, {"required": true, "name": "cisco_dna_center_account", "label": "Cisco DNA Center Account", "default_value": "", "placeholder": "", "help_string": "", "possible_values": [], "type": "global_account", "format_type": "global_account", "value": "account0"}], "data_inputs_options": [{"type": "customized_var", "name": "cisco_dna_center_host", "title": "Cisco DNA Center Host", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "cisco_dna_center_account", "title": "Cisco DNA Center Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport datetime\nimport json\nimport os\nimport sys\nimport time\n\nimport cisco_dnac_api as api\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef get_epoch_current_previous_times(interval_seconds):\n    \"\"\"\n    This function will return the epoch time for the {timestamp} and a previous epoch time\n    :return: epoch time (now) including msec, epoch time (previous) including msec\n    \"\"\"\n    # REVIEW: It is recommended that this time matches the Splunk's data input interval\n    now = datetime.datetime.now()\n    rounded = now - datetime.timedelta(\n        minutes=now.minute,\n        seconds=now.second % interval_seconds + interval_seconds if interval_seconds > 0 else now.second,\n        microseconds=now.microsecond)\n    return (int(now.timestamp() * 1000), int(rounded.timestamp() * 1000))\n\n\ndef simplify_device_health(device_health_response):\n    \"\"\"\n    This function will simplify the device health data for Splunk searches\n    :param device_item: device health data\n    :return: new device health response\n    \"\"\"\n    response = {}\n    if device_health_response:\n        response['DeviceName'] = device_health_response.get('name')\n        response['DeviceModel'] = device_health_response.get('model')\n        response['DeviceLocation'] = device_health_response.get('location')\n        response['DeviceIpAddress'] = device_health_response.get('ipAddress')\n        response['DeviceFamily'] = device_health_response.get('deviceFamily')\n        response['DeviceType'] = device_health_response.get('deviceType')\n        response['DeviceMACAddress'] = device_health_response.get('macAddress')\n    return response\n\ndef simplify_devices_health(dnac, devices_health_responses):\n    \"\"\"\n    This function will simplify the device health data and add the fabric site\n    :param dnac: Cisco DNAC SDK api\n    :param devices_health_responses: devices health response\n    :return: new fabric devices response\n    \"\"\"\n    fabric_devices_response = []\n    for device_health in devices_health_responses:\n        device = simplify_device_health(device_health)\n        device_key = device['DeviceLocation']\n        fabric_site = get_simplified_fabric_site(dnac, device_key)\n        fabric_device_new = dict(device)\n        if fabric_site:\n            fabric_device_new.update({'HasFabric': 'True'})\n        else:\n            fabric_device_new.update({'HasFabric': 'False'})\n        fabric_device_new.update(fabric_site)\n        fabric_devices_response.append(fabric_device_new)\n    return fabric_devices_response\n\ndef get_device_health(dnac, input_interval):\n    \"\"\"\n    This function will retrieve the device health from a previous time to the time the function is called\n    :param dnac: Cisco DNAC SDK api\n    :return: device health response\n    \"\"\"\n    (epoch_current_time, epoch_previous_time) = get_epoch_current_previous_times(input_interval)\n    limit = 20\n    offset = 1\n    devices_responses = []\n    do_request_next = True\n    while do_request_next:\n        try:\n            health_response = dnac.devices.devices(start_time=epoch_previous_time, end_time=epoch_current_time, limit=limit, offset=offset)\n            if health_response and health_response.response:\n                devices_responses.extend(simplify_devices_health(dnac, health_response.response))\n                if len(health_response.response) < limit:\n                    do_request_next = False\n                    break\n            else:\n                do_request_next = False\n                break\n        except Exception:\n            do_request_next = False\n            break\n        offset = offset + limit\n    return devices_responses\n\ndef get_simplified_fabric_site(dnac, site_name_hierarchy):\n    \"\"\"\n    This function will retrieve the fabric site and simplify them\n    :param dnac: Cisco DNAC SDK api\n    :param site_name_hierarchy: site name hierarchy\n    :return: fabric site response\n    \"\"\"\n    response = {}\n    try:\n        fabric_site = dnac.sda.get_site(site_name_hierarchy)\n        if fabric_site.get('status') == 'success':\n            response['FabricSiteNameHierarchy'] = fabric_site.get('siteNameHierarchy') or ''\n            response['FabricName'] = fabric_site.get('fabricName') or ''\n            response['FabricType'] = fabric_site.get('fabricType') or ''\n            response['FabricDomainType'] = fabric_site.get('fabricDomainType') or ''\n        return response\n    except Exception:\n        return response\n\n\ndef is_different(state, item):\n    if not isinstance(state, dict):\n        return True\n    if not isinstance(item, dict):\n        return True\n    keys = set(state.keys())\n    keys = keys.union(set(item.keys()))\n    properties = list(keys)\n    for property in properties:\n        if state.get(property) != item.get(property):\n            return True\n    return False\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    cisco_dna_center_host = definition.parameters.get('cisco_dna_center_host', None)\n    cisco_dna_center_account = definition.parameters.get('cisco_dna_center_account', None)\n    pass\n\ndef collect_events(helper, ew):\n    opt_cisco_dna_center_host = helper.get_arg('cisco_dna_center_host')\n    opt_cisco_dna_center_account = helper.get_arg('cisco_dna_center_account')\n\n    account_username = opt_cisco_dna_center_account.get(\"username\", None)\n    account_password = opt_cisco_dna_center_account.get(\"password\", None)\n    account_name = opt_cisco_dna_center_account.get(\"name\", None)\n    current_version = \"2.2.3.3\"\n    current_verify = False\n    current_debug = False\n\n    # use default input_interval\n    input_interval = 900\n    try:\n        input_interval = int(helper.get_arg(\"interval\"))\n    except ValueError as e:\n        input_interval = 900\n\n    dnac = api.DNACenterAPI(\n        username=account_username,\n        password=account_password,\n        base_url=opt_cisco_dna_center_host,\n        version=current_version,\n        verify=current_verify,\n        debug=current_debug)\n\n    # get the devices (health) and fabric sites associated with them\n    devices_health = get_device_health(dnac, input_interval)\n\n    r_json = []\n    for item in devices_health:\n        key = \"{0}_{1}\".format(opt_cisco_dna_center_host, item['DeviceIpAddress'])\n        state = helper.get_check_point(key)\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        if state is None:\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        elif is_different(state, item):\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        # helper.delete_check_point(key)\n\n    # To create a splunk event\n    event = helper.new_event(json.dumps(devices_health), time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    ew.write_event(event)\n", "customized_options": [{"name": "cisco_dna_center_host", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "value": "account0"}], "uuid": "9b5dd63e867149efa518eeb11ac0a40c", "sample_count": "4"}, {"index": "default", "sourcetype": "cisco:dnac:compliance", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "cisco_dnac_compliance", "title": "cisco_dnac_compliance", "description": "", "type": "customized", "parameters": [{"required": true, "name": "cisco_dna_center_host", "label": "Cisco DNA Center Host", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": "https://sandboxdnac.cisco.com"}, {"required": true, "name": "cisco_dna_center_account", "label": "Cisco DNA Center Account", "default_value": "", "placeholder": "", "help_string": "", "possible_values": [], "type": "global_account", "format_type": "global_account", "value": "account0"}], "data_inputs_options": [{"type": "customized_var", "name": "cisco_dna_center_host", "title": "Cisco DNA Center Host", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "cisco_dna_center_account", "title": "Cisco DNA Center Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport datetime\nimport json\nimport os\nimport sys\nimport time\n\nimport cisco_dnac_api as api\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef get_important_device_values(device_item):\n    \"\"\"\n    This function will simplify the device data for Splunk searches\n    :param device_item: device data\n    :return: new device response\n    \"\"\"\n    response = {}\n    response['DeviceName'] = device_item.get('hostname') or 'NA'\n    response['IpAddress'] = device_item.get('managementIpAddress') or device_item.get('ipAddress') or ''\n    response['DeviceFamily'] = device_item.get('family') or ''\n    response['Reachability'] = device_item.get('reachabilityStatus') or ''\n    response['ReachabilityFailureReason'] = device_item.get('reachabilityFailureReason') or ''\n    # Section to set the value of Manageability and ManageErrors\n    response['ManageErrors'] = ''\n    if device_item.get('managementState') == \"Managed\":\n        response['Manageability'] = \"Managed\"\n        if device_item.get('collectionStatus') and device_item['collectionStatus'] != \"Managed\":\n            response['Manageability'] = \"Managed (With Errors)\"\n            response['ManageErrors'] = device_item['collectionStatus']\n    elif device_item.get('managementState') in [\"Unmanaged\", \"Never Managed\"]:\n        response['Manageability'] = \"Unmanaged\"\n    else:\n        response['Manageability'] = \"Managed (With Errors)\"\n    response['MACAddress'] = device_item.get('macAddress') or device_item.get('apEthernetMacAddress') or ''\n    response['DeviceRole'] = device_item.get('role') or 'UNKNOWN'\n    response['ImageVersion'] = device_item.get('softwareVersion') or ''\n    response['Uptime'] = device_item.get('upTime') or ''\n    if device_item.get('uptimeSeconds') is not None:\n        response['UptimeSeconds'] = device_item.get('uptimeSeconds')\n    else:\n        response['UptimeSeconds'] = 0\n    response['LastUpdated'] = device_item.get('lastUpdated') or ''\n    if device_item.get('lastUpdateTime') is not None:\n        response['LastUpdateTime'] = device_item.get('lastUpdateTime')\n    else:\n        response['LastUpdateTime'] = 0\n    response['SerialNumber'] = device_item.get('serialNumber') or ''\n    response['DeviceSeries'] = device_item.get('series') or ''\n    response['Platform'] = device_item.get('platformId') or ''\n    response['SupportType'] = device_item.get('deviceSupportLevel') or ''\n    response['AssociatedWLCIP'] = device_item.get('associatedWlcIp') or ''\n    return response\n\ndef get_simplified_compliance(compliance_item):\n    \"\"\"\n    This function will simplify the compliance data for Splunk searches\n    :param compliance_item: compliance data\n    :return: new compliance response\n    \"\"\"\n    response = {}\n    response['ComplianceDeviceID'] = compliance_item.get('deviceUuid') or compliance_item.get('deviceId') or ''\n    response['ComplianceComplianceType'] = compliance_item.get('complianceType') or ''\n    response['ComplianceStatus'] = compliance_item.get('status') or ''\n    response['ComplianceState'] = compliance_item.get('state') or ''\n    response['ComplianceLastSyncTime'] = compliance_item.get('lastSyncTime') or 0\n    response['ComplianceLastUpdateTime'] = compliance_item.get('lastUpdateTime') or 0\n    return response\n\ndef simplified_complaince_page(dnac, compliance_page_response, devices_retrieved):\n    \"\"\"\n    This function will retrieve the compliance details and devices data as necessary\n    :param dnac: Cisco DNAC SDK api\n    :return: compliance details response\n    \"\"\"\n    simplified_complaince_response = []\n    for compliance in compliance_page_response:\n        simplified_complaince = dict(get_simplified_compliance(compliance))\n        device_key = simplified_complaince['ComplianceDeviceID']\n        # Manage device info ...\n        device_info = {}\n        # ... if already present, reuse\n        if devices_retrieved.get(device_key):\n            device_info = dict(devices_retrieved[device_key])\n        else:  # ... if not retrieve and save it\n            device_info = dnac.devices.get_device_by_id(id=device_key)\n            devices_retrieved[device_key] = device_info\n        if isinstance(device_info, dict) and device_info.get('response'):\n            simplified_complaince.update(get_important_device_values(device_info['response']))\n        simplified_complaince_response.append(simplified_complaince)\n    return simplified_complaince_response\n\ndef get_compliance_and_device_details(dnac):\n    \"\"\"\n    This function will retrieve the compliance details and devices as necessary\n    :param dnac: Cisco DNAC SDK api\n    :return: compliance details response\n    \"\"\"\n    limit = 20\n    offset = 1\n    compliances_response = []\n    do_request_next = True\n    devices_retrieved = {}\n    while do_request_next:\n        try:\n            compliance_page_response = dnac.compliance.get_compliance_detail(limit=str(limit), offset=str(offset))\n            if compliance_page_response and compliance_page_response.response:\n                compliances_response.extend(simplified_complaince_page(dnac, compliance_page_response.response, devices_retrieved))\n                if len(compliance_page_response.response) < limit:\n                    do_request_next = False\n                    break\n            else:\n                do_request_next = False\n                break\n        except Exception:\n            do_request_next = False\n            break\n        offset = offset + limit\n    return compliances_response\n\ndef is_different(state, item):\n    if not isinstance(state, dict):\n        return True\n    if not isinstance(item, dict):\n        return True\n    keys = set(state.keys())\n    keys = keys.union(set(item.keys()))\n    properties = list(keys)\n    for property_ in properties:\n        # if property_ in ['UptimeSeconds', 'ComplianceLastSyncTime', 'ComplianceLastUpdateTime']:\n        #     continue\n        if state.get(property_) != item.get(property_):\n            return True\n    return False\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    cisco_dna_center_host = definition.parameters.get('cisco_dna_center_host', None)\n    cisco_dna_center_account = definition.parameters.get('cisco_dna_center_account', None)\n    pass\n\ndef collect_events(helper, ew):\n    opt_cisco_dna_center_host = helper.get_arg('cisco_dna_center_host')\n    opt_cisco_dna_center_account = helper.get_arg('cisco_dna_center_account')\n\n    account_username = opt_cisco_dna_center_account.get(\"username\", None)\n    account_password = opt_cisco_dna_center_account.get(\"password\", None)\n    account_name = opt_cisco_dna_center_account.get(\"name\", None)\n    current_version = \"2.2.3.3\"\n    current_verify = False\n    current_debug = False\n\n    dnac = api.DNACenterAPI(\n        username=account_username,\n        password=account_password,\n        base_url=opt_cisco_dna_center_host,\n        version=current_version,\n        verify=current_verify,\n        debug=current_debug)\n\n    r_json = []\n    # get the compliance details and devices data as necessary\n    overall_compliance_details = get_compliance_and_device_details(dnac)\n\n    for item in overall_compliance_details:\n        key = \"{0}_{1}_{2}_{3}\".format(opt_cisco_dna_center_host, item.get('ComplianceDeviceID') or \"NA\", item.get('ComplianceComplianceType') or \"NA\", item.get('IpAddress') or \"NA\")\n        state = helper.get_check_point(key)\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        if state is None:\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        elif is_different(state, item):\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        # helper.delete_check_point(key)\n\n    # To create a splunk event\n    event = helper.new_event(json.dumps(r_json), time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    ew.write_event(event)\n", "customized_options": [{"name": "cisco_dna_center_host", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "value": "account0"}], "uuid": "8e3b0edfc9914ceeb4500258cdf1d647", "sample_count": "12"}, {"index": "default", "sourcetype": "cisco:dnac:image", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "cisco_dnac_image", "title": "cisco_dnac_image", "description": "", "type": "customized", "parameters": [{"required": true, "name": "cisco_dna_center_host", "label": "Cisco DNA Center Host", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": ""}, {"required": true, "name": "cisco_dna_center_account", "label": "Cisco DNA Center Account", "default_value": "", "placeholder": "", "help_string": "", "possible_values": [], "type": "global_account", "format_type": "global_account", "value": ""}], "data_inputs_options": [{"type": "customized_var", "name": "cisco_dna_center_host", "title": "Cisco DNA Center Host", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "cisco_dna_center_account", "title": "Cisco DNA Center Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport json\nimport sys\nimport time\nimport datetime\n\nimport cisco_dnac_api as api\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef get_important_image_details(details):\n    \"\"\"\n    This function will simplify the image details for Splunk searches\n    :param details: image details\n    :return: simplified image response\n    \"\"\"\n    response = {}\n    if details:\n        response['DeviceImageUpgradeStatus'] = details.get('deviceImageUpgradeStatus') or ''\n        response['UpgradeStatus'] = details.get('upgradeStatus') or ''\n        response['DeviceInstalledInfoImageUuid'] = ''\n        response['DeviceInstalledInfoName'] = ''\n        response['DeviceInstalledInfoType'] = ''\n        response['DeviceInstalledInfoVersion'] = ''\n        response['DeviceInstalledInfoDisplayVersion'] = ''\n        response['DeviceInstalledInfoFamily'] = ''\n        response['DeviceInstalledInfoGolden'] = 'False'\n        response['DeviceInstalledInfoSubpackageType'] = ''\n        response['HasTargetImageInfo'] = 'False'\n        response['ReadinessCheckStatusStatus'] = ''\n        response['ReadinessCheckStatusIsReadyForUpgrade'] = 'False'\n        if details.get('deviceInstalledInfo') and isinstance(details['deviceInstalledInfo'], list):\n            if len(details['deviceInstalledInfo']) > 0:\n                response['DeviceInstalledInfoImageUuid'] = details['deviceInstalledInfo'][0].get('imageUuid') or ''\n                response['DeviceInstalledInfoName'] = details['deviceInstalledInfo'][0].get('name') or ''\n                response['DeviceInstalledInfoType'] = details['deviceInstalledInfo'][0].get('type') or ''\n                response['DeviceInstalledInfoVersion'] = details['deviceInstalledInfo'][0].get('version') or ''\n                response['DeviceInstalledInfoDisplayVersion'] = details['deviceInstalledInfo'][0].get('displayVersion') or ''\n                response['DeviceInstalledInfoFamily'] = details['deviceInstalledInfo'][0].get('family') or ''\n                response['DeviceInstalledInfoGolden'] = str(details['deviceInstalledInfo'][0].get('golden')) or 'False'\n                response['DeviceInstalledInfoSubpackageType'] = details['deviceInstalledInfo'][0].get('subpackageType') or ''\n        if details.get('targetImageInfo') and isinstance(details['targetImageInfo'], list):\n            response['HasTargetImageInfo'] = 'True'\n            response['TargetImageInfo'] = details['targetImageInfo']\n        if details.get('readinessCheckStatus') and isinstance(details['readinessCheckStatus'], dict):\n            response['ReadinessCheckStatusStatus'] = details['readinessCheckStatus'].get('status')\n            response['ReadinessCheckStatusIsReadyForUpgrade'] = str(details['readinessCheckStatus'].get('isReadyForUpgrade'))\n    return response\n\ndef get_device_image_stack_details(dnac, device_id):\n    \"\"\"\n    This function will retrieve the specific device image stack details\n    :param dnac: Cisco DNAC SDK api\n    :param device_id: device id\n    :return: device image stack response\n    \"\"\"\n    try:\n        stack_details = dnac.devices.get_stack_details_for_device(device_id)\n        if stack_details and stack_details.response:\n            return stack_details.response\n        return None\n    except:\n        return None\n\ndef get_devices(dnac):\n    \"\"\"\n    This function will retrieve all the devices\n    :param dnac: Cisco DNAC SDK api\n    :return: devices response\n    \"\"\"\n    limit = 20\n    offset = 1\n    devices_responses = []\n    do_request_next = True\n    while do_request_next:\n        try:\n            device_response = dnac.devices.get_device_list(limit=limit, offset=offset)\n            if device_response and device_response.response:\n                devices_responses.extend(device_response.response)\n                if len(device_response.response) < limit:\n                    do_request_next = False\n                    break\n            else:\n                do_request_next = False\n                break\n        except Exception:\n            do_request_next = False\n            break\n        offset = offset + limit\n    return devices_responses\n\ndef get_important_device_values(device_item):\n    \"\"\"\n    This function will simplify the device information for Splunk searches\n    :param device_item: device information\n    :return: simplified device response\n    \"\"\"\n    response = {}\n    response['DeviceID'] = device_item.get('id') or ''\n    response['DeviceName'] = device_item.get('hostname') or 'NA'\n    response['DeviceIpAddress'] = device_item.get('managementIpAddress') or device_item.get('ipAddress') or ''\n    response['DeviceFamily'] = device_item.get('family') or ''\n    response['DeviceMACAddress'] = device_item.get('macAddress') or device_item.get('apEthernetMacAddress') or ''\n    response['DeviceRole'] = device_item.get('role') or 'UNKNOWN'\n    response['DeviceImageVersion'] = device_item.get('softwareVersion') or ''\n    response['DeviceUptime'] = device_item.get('upTime') or ''\n    if device_item.get('uptimeSeconds') is not None:\n        response['DeviceUptimeSeconds'] = device_item.get('uptimeSeconds')\n    else:\n        response['DeviceUptimeSeconds'] = 0\n    response['DeviceLastUpdated'] = device_item.get('lastUpdated') or ''\n    if device_item.get('lastUpdateTime') is not None:\n        response['DeviceLastUpdateTime'] = device_item.get('lastUpdateTime')\n    else:\n        response['DeviceLastUpdateTime'] = 0\n    response['DeviceSerialNumber'] = device_item.get('serialNumber') or ''\n    response['DeviceSeries'] = device_item.get('series') or ''\n    response['DevicePlatform'] = device_item.get('platformId') or ''\n    response['DeviceSupportType'] = device_item.get('deviceSupportLevel') or ''\n    return response\n\ndef get_important_stack_details(details):\n    \"\"\"\n    This function will simplify the image stack details for Splunk searches\n    :param details: image stack details\n    :return: simplified image stack response\n    \"\"\"\n    response = {'HasStack': 'False'}\n    response['SwitchInfoAmount'] = 0\n    response['StackSwitchInfoSoftwareImage'] = 'N/A'\n    response['StackSwitchInfoRole'] = ''\n    response['StackSwitchInfoState'] = ''\n    response['StackSwitchInfoIsReady'] = 'False'\n    response['SwitchInfo'] = []\n    response['StackPortInfoAmount'] = 0\n    response['StackPortInfo'] = []\n    response['StackSvlSwitchInfoAmount'] = 0\n    response['StackSvlSwitchInfo'] = []\n    if details:\n        if details.get('stackSwitchInfo'):\n            response['HasStack'] = 'True'\n            response['SwitchInfoAmount'] = len(details['stackSwitchInfo']) if isinstance(details['stackSwitchInfo'], list) else 0\n            response['SwitchInfo'] = details['stackSwitchInfo']\n            if len(details.get('stackSwitchInfo')) > 0:\n                response['StackSwitchInfoSoftwareImage'] = details['stackSwitchInfo'][0].get('softwareImage') or 'N/A'\n                response['StackSwitchInfoRole'] = details['stackSwitchInfo'][0].get('role') or ''\n                response['StackSwitchInfoState'] = details['stackSwitchInfo'][0].get('state') or ''\n                response['StackSwitchInfoIsReady'] = str(details['stackSwitchInfo'][0].get('state') == \"READY\")\n        if details.get('stackPortInfo'):\n            response['HasStack'] = 'True'\n            response['StackPortInfoAmount'] = len(details['stackPortInfo']) if isinstance(details['stackPortInfo'], list) else 0\n            response['StackPortInfo'] = details['stackPortInfo']\n        if details.get('svlSwitchInfo'):\n            response['HasStack'] = 'True'\n            response['StackSvlSwitchInfoAmount'] = len(details['svlSwitchInfo']) if isinstance(details['svlSwitchInfo'], list) else 0\n            response['StackSvlSwitchInfo'] = details['svlSwitchInfo']\n    return response\n\n\ndef filter_data_as_images_1(dnac, images_items, devices_items):\n    \"\"\"\n    This function will filter data to get the overall image health data.\n    :param dnac: Cisco DNAC SDK api\n    :param images_items: images\n    :param devices_items: devices\n    :return: image health summary response\n    \"\"\"\n    summary_response = []\n    image_dict_summary = {}\n    image_dict = {}\n\n    for image_item in images_items:\n        image_key = image_item['ImageSimpleName'].lower()\n        image_dict_summary[image_key] = dict(image_item)\n        image_dict_summary[image_key]['ImageDevicesAmount'] = 0\n        image_dict_summary[image_key]['ImageSummary'] = 'True'\n        image_dict[image_key] = dict(image_item)\n        image_dict[image_key]['ImageDevicesAmount'] = 0\n        image_dict[image_key]['ImageSummary'] = 'False'\n\n    for device_item in devices_items:\n        stack_detail = get_important_stack_details(get_device_image_stack_details(dnac, device_item.get('id')))\n        stack_detail_key = 'StackSwitchInfoSoftwareImage'\n\n        device_detail = get_important_device_values(device_item)\n\n        if stack_detail.get(stack_detail_key) != \"N/A\":\n            software_image = stack_detail[stack_detail_key].lower()\n            if image_dict_summary.get(software_image):\n                image_dict_summary[software_image]['ImageDevicesAmount'] += 1\n                image_dict[software_image]['ImageDevicesAmount'] = 1\n                image_dict[software_image].update(device_detail)\n                image_dict[software_image].update(stack_detail)\n                summary_response.append(dict(image_dict[software_image]))\n        else:\n            image_key_2 = stack_detail[stack_detail_key].lower()\n            if image_dict_summary.get(image_key_2) is None:\n                image_dict_summary[image_key_2] = {'ImageDevicesAmount': 0, 'ImageSummary': 'True'}\n            if image_dict_summary.get(image_key_2):\n                image_dict_summary[image_key_2]['ImageDevicesAmount'] += 1\n                image_dict_summary[image_key_2]['ImageName'] = 'N/A'\n                image_dict_summary[image_key_2]['ImageImageName'] = 'N/A'\n                image_dict_summary[image_key_2]['ImageImageUuid'] = ''\n                image_dict_summary[image_key_2]['ImageFamily'] = ''\n                image_dict_summary[image_key_2]['ImageVersion'] = ''\n                image_dict_summary[image_key_2]['ImageDisplayVersion'] = ''\n                image_dict_summary[image_key_2]['ImageSimpleName'] = image_key_2\n\n                image_dict[image_key_2] = dict(image_dict_summary[image_key_2])\n                image_dict[image_key_2]['ImageSummary'] = 'False'\n                image_dict[image_key_2]['ImageDevicesAmount'] = 1\n                image_dict[image_key_2].update(device_detail)\n                image_dict[image_key_2].update(stack_detail)\n                summary_response.append(dict(image_dict[image_key_2]))\n    summary_response.extend(list(image_dict_summary.values()))\n    return summary_response\n\n\ndef filter_data_as_images(dnac, images_items, devices_items):\n    \"\"\"\n    This function will call another function that filters data to get the overall image health data.\n    :param dnac: Cisco DNAC SDK api\n    :param images_items: images\n    :param devices_items: devices\n    :return: image health summary response\n    \"\"\"\n    return filter_data_as_images_1(dnac, images_items, devices_items)\n\ndef simplify_name(name, display_version):\n    \"\"\"\n    This function trims from the image name, removing the display_version and other information, to use the new image name as an index.\n    :param name: image name\n    :param display_version: image display version\n    :return: simplified image name\n    \"\"\"\n    if name:\n        if display_version:\n            new_name = name.split(\".{0}\".format(display_version))[0]\n            return new_name\n        return name\n    else:\n        return \"\"\n\ndef get_images(dnac):\n    \"\"\"\n    This function will retrieve the images found in SWIM\n    :param dnac: Cisco DNAC SDK api\n    :return: images response\n    \"\"\"\n    responses = []\n    images_response_fn = None\n    images_response = None\n    # Select function\n    if hasattr(dnac, 'software_image_management_swim'):\n        images_response_fn = dnac.software_image_management_swim.get_software_image_details\n    elif hasattr(dnac, 'swim'):\n        images_response_fn = dnac.swim.get_software_image_details\n    # If not found return fast (fail silently)\n    if images_response_fn is None:\n        return responses\n\n    limit = 20\n    offset = 1\n    do_request_next = True\n    while do_request_next:\n        try:\n            images_response = images_response_fn(limit=limit, offset=offset)\n            if images_response and images_response.response:\n                for image_response in images_response.response:\n                    response = {}\n                    response['ImageName'] = image_response.get('name')\n                    response['ImageImageName'] = image_response.get('imageName')\n                    response['ImageImageUuid'] = image_response.get('imageUuid')\n                    response['ImageFamily'] = image_response.get('family')\n                    response['ImageVersion'] = image_response.get('version')\n                    response['ImageDisplayVersion'] = image_response.get('displayVersion')\n                    response['ImageSimpleName'] = simplify_name(image_response.get('name'), image_response.get('displayVersion'))\n                    responses.append(response)\n                if len(images_response.response) < limit:\n                    do_request_next = False\n                    break\n            else:\n                do_request_next = False\n                break\n        except Exception:\n            do_request_next = False\n            break\n        offset = offset + limit\n    return responses\n\ndef is_different(state, item):\n    if not isinstance(state, dict):\n        return True\n    if not isinstance(item, dict):\n        return True\n    keys = set(state.keys())\n    keys = keys.union(set(item.keys()))\n    properties = list(keys)\n    for property in properties:\n        if state.get(property) != item.get(property):\n            return True\n    return False\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    cisco_dna_center_host = definition.parameters.get('cisco_dna_center_host', None)\n    cisco_dna_center_account = definition.parameters.get('cisco_dna_center_account', None)\n    pass\n\ndef collect_events(helper, ew):\n    opt_cisco_dna_center_host = helper.get_arg('cisco_dna_center_host')\n    opt_cisco_dna_center_account = helper.get_arg('cisco_dna_center_account')\n\n    account_username = opt_cisco_dna_center_account.get(\"username\", None)\n    account_password = opt_cisco_dna_center_account.get(\"password\", None)\n    account_name = opt_cisco_dna_center_account.get(\"name\", None)\n    current_version = \"2.2.3.3\"\n    current_verify = False\n    current_debug = False\n\n    # use default input_interval\n    input_interval = 900\n    try:\n        input_interval = int(helper.get_arg(\"interval\"))\n    except ValueError as e:\n        input_interval = 900\n\n    dnac = api.DNACenterAPI(\n        username=account_username,\n        password=account_password,\n        base_url=opt_cisco_dna_center_host,\n        version=current_version,\n        verify=current_verify,\n        debug=current_debug)\n\n    r_json = []\n\n    # get the devices\n    devices_items = get_devices(dnac)\n    # get the images\n    images_items = get_images(dnac)\n    # merge and simplify gathered information\n    overall_result = filter_data_as_images(dnac, images_items, devices_items)\n\n\n    for item in overall_result:\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        if item[\"ImageSummary\"] == \"True\":\n            key = \"{0}_{1}\".format(opt_cisco_dna_center_host, item.get('ImageName'))\n            state = helper.get_check_point(key)\n            if state is None:\n                helper.save_check_point(key, item)\n                r_json.append(item)\n            elif is_different(state, item):\n                helper.save_check_point(key, item)\n                r_json.append(item)\n            # helper.delete_check_point(key)\n        else:\n            key = \"{0}_{1}_{2}\".format(opt_cisco_dna_center_host, item.get('ImageName'), item.get('DeviceID'))\n            state = helper.get_check_point(key)\n            if state is None:\n                helper.save_check_point(key, item)\n                r_json.append(item)\n            elif is_different(state, item):\n                helper.save_check_point(key, item)\n                r_json.append(item)\n            # helper.delete_check_point(key)\n\n    # To create a splunk event\n    event = helper.new_event(json.dumps(r_json), time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    ew.write_event(event)\n", "customized_options": [{"name": "cisco_dna_center_host", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "value": "account0"}], "uuid": "3e0f400c72e044cb9ad872a83d015951"}, {"index": "default", "sourcetype": "cisco:dnac:issue", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "cisco_dnac_issue", "title": "cisco_dnac_issue", "description": "", "type": "customized", "parameters": [{"name": "cisco_dna_center_host", "label": "Cisco DNA Center Host", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "label": "Cisco DNA Center Account", "help_string": "", "required": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": "", "type": "global_account", "value": "account0"}, {"required": false, "name": "status", "label": "Status", "default_value": " ", "placeholder": "", "help_string": "", "possible_values": [{"value": " ", "label": "All"}, {"value": "ACTIVE", "label": "ACTIVE"}, {"value": "IGNORED", "label": "IGNORED"}, {"label": "RESOLVED", "value": "RESOLVED"}], "type": "dropdownlist", "format_type": "dropdownlist", "value": " "}, {"required": false, "name": "priorities", "label": "Priorities", "default_value": [], "help_string": "", "placeholder": "", "possible_values": [{"value": "P1", "label": "P1"}, {"value": "P2", "label": "P2"}, {"value": "P3", "label": "P3"}, {"label": "P4", "value": "P4"}], "type": "multi_dropdownlist", "format_type": "multi_dropdownlist", "value": []}], "data_inputs_options": [{"type": "customized_var", "name": "cisco_dna_center_host", "title": "Cisco DNA Center Host", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "cisco_dna_center_account", "title": "Cisco DNA Center Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "status", "title": "Status", "description": "", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": " ", "label": "All"}, {"value": "ACTIVE", "label": "ACTIVE"}, {"value": "IGNORED", "label": "IGNORED"}, {"label": "RESOLVED", "value": "RESOLVED"}], "format_type": "dropdownlist", "default_value": " ", "placeholder": ""}, {"type": "customized_var", "name": "priorities", "title": "Priorities", "description": "", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "P1", "label": "P1"}, {"value": "P2", "label": "P2"}, {"value": "P3", "label": "P3"}, {"label": "P4", "value": "P4"}], "format_type": "multi_dropdownlist", "default_value": [], "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport json\nimport sys\nimport time\nimport datetime\n\nimport cisco_dnac_api as api\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef get_epoch_current_previous_times(interval_seconds):\n    \"\"\"\n    This function will return the epoch time for the {timestamp} and a previous epoch time\n    :return: epoch time (now) including msec, epoch time (previous) including msec\n    \"\"\"\n    # REVIEW: It is recommended that this time matches the Splunk's data input interval\n    now = datetime.datetime.now()\n    rounded = now - datetime.timedelta(\n        minutes=now.minute,\n        seconds=now.second % interval_seconds + interval_seconds if interval_seconds > 0 else now.second,\n        microseconds=now.microsecond)\n    return (int(now.timestamp() * 1000), int(rounded.timestamp() * 1000))\n\ndef get_important_device_values(device_item):\n    \"\"\"\n    This function will simplify the device information for Splunk searches\n    :param device_item: device information\n    :return: simplified device response\n    \"\"\"\n    response = {}\n    response['DeviceID'] = device_item.get('id') or ''\n    response['DeviceName'] = device_item.get('hostname') or 'NA'\n    response['DeviceIpAddress'] = device_item.get('managementIpAddress') or device_item.get('ipAddress') or ''\n    response['DeviceFamily'] = device_item.get('family') or ''\n    response['DeviceMACAddress'] = device_item.get('macAddress') or device_item.get('apEthernetMacAddress') or ''\n    response['DeviceRole'] = device_item.get('role') or 'UNKNOWN'\n    response['DeviceImageVersion'] = device_item.get('softwareVersion') or ''\n    response['DeviceUptime'] = device_item.get('upTime') or ''\n    if device_item.get('uptimeSeconds') is not None:\n        response['DeviceUptimeSeconds'] = device_item.get('uptimeSeconds')\n    else:\n        response['DeviceUptimeSeconds'] = 0\n    response['DeviceLastUpdated'] = device_item.get('lastUpdated') or ''\n    if device_item.get('lastUpdateTime') is not None:\n        response['DeviceLastUpdateTime'] = device_item.get('lastUpdateTime')\n    else:\n        response['DeviceLastUpdateTime'] = 0\n    response['DeviceSerialNumber'] = device_item.get('serialNumber') or ''\n    response['DeviceSeries'] = device_item.get('series') or ''\n    response['DevicePlatform'] = device_item.get('platformId') or ''\n    response['DeviceSupportType'] = device_item.get('deviceSupportLevel') or ''\n    return response\n\ndef simplify_issue(issue_responses):\n    \"\"\"\n    This function will simplify the site data for Splunk searches\n    :param issue_resp: Cisco DNAC SDK api\n    :return: new site response\n    \"\"\"\n    simplified_issue = {}\n    if len(issue_responses) > 0 and isinstance(issue_responses[0], dict):\n        issue_resp = issue_responses[0]\n        simplified_issue['IssueID'] = issue_resp.get('issueId')\n        simplified_issue['IssueSpecificCategory'] = issue_resp.get('issueCategory')\n        simplified_issue['IssueSpecificSource'] = issue_resp.get('issueSource')\n        simplified_issue['IssueSpecificName'] = issue_resp.get('issueName')\n        simplified_issue['IssueSpecificDescription'] = issue_resp.get('issueDescription')\n        simplified_issue['IssueSpecificEntity'] = issue_resp.get('issueEntity')\n        simplified_issue['IssueSpecificEntityValue'] = issue_resp.get('issueEntityValue')\n        simplified_issue['IssueSpecificSeverity'] = issue_resp.get('issueSeverity')\n        simplified_issue['IssueSpecificPriority'] = issue_resp.get('issuePriority')\n        simplified_issue['IssueSpecificSummary'] = issue_resp.get('issueSummary')\n        simplified_issue['IssueSpecificTimestamp'] = issue_resp.get('issueTimestamp')\n        return simplified_issue\n    else:\n        return {}\n\ndef simplify_site(site_resp):\n    \"\"\"\n    This function will simplify the site data for Splunk searches\n    :param site_resp: Cisco DNAC SDK api\n    :return: new site response\n    \"\"\"\n    simplified_site = {}\n    if site_resp:\n        simplified_site['SiteName'] = site_resp.get('name')\n        simplified_site['SiteNameHierarchy'] = site_resp.get('siteNameHierarchy')\n        simplified_site['SiteType'] = 'area'\n        if site_resp.get('additionalInfo'):\n            if len(site_resp['additionalInfo']) > 0:\n                for additional_info in site_resp['additionalInfo']:\n                    if isinstance(additional_info, dict) and additional_info.get('attributes'):\n                        if isinstance(additional_info['attributes'], dict) and additional_info['attributes'].get('type'):\n                            simplified_site['SiteType'] = additional_info['attributes'].get('type')\n        return simplified_site\n    else:\n        return {}\n\ndef clean_dict_of_empty_strings(**kwargs):\n    dict_ = {**kwargs}\n    dict_new = {}\n    for key,value in dict_.items():\n        if isinstance(value, str) and value != \"\":\n            dict_new[key] = value\n    return dict_new\n\ndef get_issues(dnac, interval_seconds, **kwargs):\n    \"\"\"\n    This function will retrieve the issue details and devices&site data as necessary\n    :param dnac: Cisco DNAC SDK api\n    :param interval_seconds: interval in seconds\n    :return: simplified issues and device&site response\n    \"\"\"\n    end_time, start_time = get_epoch_current_previous_times(interval_seconds)\n    responses = []\n    issues_response = dnac.issues.issues(start_time=start_time, end_time=end_time, **clean_dict_of_empty_strings(**kwargs))\n    issue_info = {}\n    site_info = {}\n    device_info = {}\n    if issues_response and issues_response.response:\n        for issue_item in issues_response.response:\n            response = {}\n            issue_id = issue_item.get('issueId') or ''\n            site_id = issue_item.get('siteId') or ''\n            device_id = issue_item.get('deviceId') or ''\n            if issue_id:\n                if issue_info.get(issue_id):\n                    response.update(issue_info[issue_id])\n                else:\n                    tmp_issue = dnac.issues.get_issue_enrichment_details(headers=dict(entity_type=\"issue_id\", entity_value=issue_id))\n                    if tmp_issue and isinstance(tmp_issue.get('issueDetails'), dict) and isinstance(tmp_issue['issueDetails'].get('issue'), list):\n                        issue_info[issue_id] = simplify_issue(tmp_issue['issueDetails']['issue'])\n                        issue_info[issue_id].update({\n                            'IssueName': issue_item.get('name') or '',\n                            'IssueDeviceRole': issue_item.get('deviceRole') or '',\n                            'IssueAiDriven': issue_item.get('aiDriven') or '',\n                            'IssueClientMac': issue_item.get('clientMac') or '',\n                            'IssueCount': issue_item.get('issue_occurence_count') or '',\n                            'IssueStatus': issue_item.get('status') or '',\n                            'IssuePriority': issue_item.get('priority') or '',\n                            'IssueCategory': issue_item.get('category') or '',\n                        })\n                        response.update(issue_info[issue_id])\n            if site_id:\n                if site_info.get(site_id):\n                    response.update(site_info[site_id])\n                else:\n                    tmp_site = dnac.sites.get_site(site_id=site_id)\n                    if tmp_site and tmp_site.response:\n                        site_info[site_id] = simplify_site(tmp_site['response'])\n                        response.update(site_info[site_id])\n            if device_id:\n                if device_info.get(device_id):\n                    response.update(device_info[device_id])\n                else:\n                    tmp_device = dnac.devices.get_device_by_id(id=device_id)\n                    if tmp_device and tmp_device.response:\n                        device_info[device_id] = get_important_device_values(tmp_device['response'])\n                        response.update(device_info[device_id])\n            responses.append(response)\n    return responses\n\ndef is_different(state, item):\n    if not isinstance(state, dict):\n        return True\n    if not isinstance(item, dict):\n        return True\n    keys = set(state.keys())\n    keys = keys.union(set(item.keys()))\n    properties = list(keys)\n    for property in properties:\n        if state.get(property) != item.get(property):\n            return True\n    return False\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    cisco_dna_center_host = definition.parameters.get('cisco_dna_center_host', None)\n    cisco_dna_center_account = definition.parameters.get('cisco_dna_center_account', None)\n    status = definition.parameters.get('status', None)\n    priorities = definition.parameters.get('priorities', None)\n    pass\n\ndef collect_events(helper, ew):\n    opt_cisco_dna_center_host = helper.get_arg('cisco_dna_center_host')\n    opt_cisco_dna_center_account = helper.get_arg('cisco_dna_center_account')\n\n    account_username = opt_cisco_dna_center_account.get(\"username\", None)\n    account_password = opt_cisco_dna_center_account.get(\"password\", None)\n    account_name = opt_cisco_dna_center_account.get(\"name\", None)\n    current_version = \"2.2.3.3\"\n    current_verify = False\n    current_debug = False\n\n    # use default input_interval\n    input_interval = 900\n    try:\n        input_interval = int(helper.get_arg(\"interval\"))\n    except ValueError as e:\n        input_interval = 900\n\n    dnac = api.DNACenterAPI(\n        username=account_username,\n        password=account_password,\n        base_url=opt_cisco_dna_center_host,\n        version=current_version,\n        verify=current_verify,\n        debug=current_debug)\n\n    r_json = []\n\n    # If empty searches and records all priority values: P1, P2, P3, or P4\n    priority = ','.join(helper.get_arg('priorities'))\n    # If empty searches and records all ai_driven values: Yes or No\n    ai_driven = \"\"\n    # If empty searches and records all issue_status values: ACTIVE, IGNORED, RESOLVED\n    issue_status = helper.get_arg('status').strip()\n    # get the issue details and devices&site data as necessary\n    overall_issues = []\n    try:\n        overall_issues = get_issues(dnac, interval_seconds=input_interval, priority=priority, ai_driven=ai_driven, issue_status=issue_status)\n    except Exception as e:\n        overall_issues = []\n\n    for item in overall_issues:\n        key = \"{0}_{1}\".format(opt_cisco_dna_center_host, item.get('IssueID'))\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        state = helper.get_check_point(key)\n        if state is None:\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        elif is_different(state, item):\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        # helper.delete_check_point(key)\n\n    # To create a splunk event\n    event = helper.new_event(json.dumps(r_json), time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    ew.write_event(event)\n", "customized_options": [{"name": "cisco_dna_center_host", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "value": "account0"}, {"name": "status", "value": " "}, {"name": "priorities", "value": []}], "uuid": "7cf958acc74849c697fa4bea844e191e"}, {"index": "default", "sourcetype": "cisco:dnac:networkhealth", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "cisco_dnac_networkhealth", "title": "cisco_dnac_networkhealth", "description": "", "type": "customized", "parameters": [{"name": "cisco_dna_center_host", "label": "Cisco DNA Center Host", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": ""}, {"name": "cisco_dna_center_account", "label": "Cisco DNA Center Account", "help_string": "", "required": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": "", "type": "global_account", "value": ""}], "data_inputs_options": [{"type": "customized_var", "name": "cisco_dna_center_host", "title": "Cisco DNA Center Host", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "cisco_dna_center_account", "title": "Cisco DNA Center Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "customized_options": [{"name": "cisco_dna_center_host", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "value": "account0"}], "code": "\n# encoding = utf-8\n\nimport datetime\nimport json\nimport os\nimport sys\nimport time\n\nimport cisco_dnac_api as api\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef get_epoch_current_time():\n    \"\"\"\n    This function will return the epoch time for the {timestamp}\n    :return: epoch time including msec\n    \"\"\"\n    epoch = time.time()*1000\n    return \"{0}\".format(int(epoch))\n\ndef get_overall_network_health(dnac):\n    \"\"\"\n    This function will retrieve the network health\n    :param dnac: Cisco DNAC SDK api\n    :return: network health response\n    \"\"\"\n    epoch_time = get_epoch_current_time()\n    network_health_fn = None\n    # Select function\n    if hasattr(dnac, 'topology') and hasattr(dnac.topology, 'get_overall_network_health'):\n        network_health_fn = dnac.topology.get_overall_network_health\n    elif hasattr(dnac, 'networks') and hasattr(dnac.networks, 'get_overall_network_health'):\n        network_health_fn = dnac.networks.get_overall_network_health\n    # If not function was found return None\n    if network_health_fn is None:\n        return None\n\n    network_health_response = network_health_fn(epoch_time)\n    return network_health_response\n\ndef filter_health_data(network_health_response):\n    \"\"\"\n    This function will filter data to get the overall network data.\n    :param network_health_response: network health response\n    :return: health summary response\n    \"\"\"\n    health_distribution = []\n    # Capture possible None\n    if network_health_response is None:\n        return health_distribution\n\n    if network_health_response.healthDistirubution:\n        health_distribution = list(network_health_response.healthDistirubution)\n\n    if network_health_response.response:\n        if len(network_health_response.response) > 0:\n            if network_health_response.response[0]:\n                key_list = [\"healthScore\", \"totalCount\", \"goodCount\", \"noHealthCount\", \"fairCount\", \"badCount\"]\n                overall_health = {\"category\": \"All\"}\n                tmp = dict(network_health_response.response[0])\n                for i in key_list:\n                    if tmp[i]:\n                        overall_health[i] = tmp[i]\n                health_distribution.append(overall_health)\n    return health_distribution\n\ndef is_different(state, item):\n    if not isinstance(state, dict):\n        return True\n    if not isinstance(item, dict):\n        return True\n    keys = set(state.keys())\n    keys = keys.union(set(item.keys()))\n    properties = list(keys)\n    for property in properties:\n        if state.get(property) != item.get(property):\n            return True\n    return False\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    cisco_dna_center_host = definition.parameters.get('cisco_dna_center_host', None)\n    cisco_dna_center_account = definition.parameters.get('cisco_dna_center_account', None)\n    pass\n\ndef collect_events(helper, ew):\n    opt_cisco_dna_center_host = helper.get_arg('cisco_dna_center_host')\n    opt_cisco_dna_center_account = helper.get_arg('cisco_dna_center_account')\n\n    account_username = opt_cisco_dna_center_account.get(\"username\", None)\n    account_password = opt_cisco_dna_center_account.get(\"password\", None)\n    account_name = opt_cisco_dna_center_account.get(\"name\", None)\n    current_version = \"2.2.3.3\"\n    current_verify = False\n    current_debug = False\n\n    dnac = api.DNACenterAPI(\n        username=account_username,\n        password=account_password,\n        base_url=opt_cisco_dna_center_host,\n        version=current_version,\n        verify=current_verify,\n        debug=current_debug)\n\n    r_json = []\n    # get the overall network health\n    overall_network_health = get_overall_network_health(dnac)\n    # simplify gathered information\n    network_health_summary = filter_health_data(overall_network_health)\n\n    for item in network_health_summary:\n        key = \"{0}_{1}\".format(opt_cisco_dna_center_host, item.get('category') or \"NA\")\n        state = helper.get_check_point(key)\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        if state is None:\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        elif is_different(state, item):\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        # helper.delete_check_point(key)\n\n    # To create a splunk event\n    event = helper.new_event(json.dumps(r_json), time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    ew.write_event(event)\n", "uuid": "7f250c39102740569f4a8ad7755bd2e4"}, {"index": "default", "sourcetype": "cisco:dnac:securityadvisory", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "cisco_dnac_securityadvisory", "title": "cisco_dnac_securityadvisory", "description": "", "type": "customized", "parameters": [{"required": true, "name": "cisco_dna_center_host", "label": "Cisco DNA Center Host", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": ""}, {"required": true, "name": "cisco_dna_center_account", "label": "Cisco DNA Center Account", "default_value": "", "placeholder": "", "help_string": "", "possible_values": [], "type": "global_account", "format_type": "global_account", "value": ""}], "data_inputs_options": [{"type": "customized_var", "name": "cisco_dna_center_host", "title": "Cisco DNA Center Host", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "cisco_dna_center_account", "title": "Cisco DNA Center Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport datetime\nimport json\nimport os\nimport sys\nimport time\n\nimport cisco_dnac_api as api\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef get_important_device_values(device_item):\n    \"\"\"\n    This function will simplify the device data for Splunk searches\n    :param device_item: device data\n    :return: new device response\n    \"\"\"\n    response = {}\n    response['DeviceName'] = device_item.get('hostname') or 'NA'\n    response['DeviceIpAddress'] = device_item.get('managementIpAddress') or device_item.get('ipAddress') or ''\n    response['DeviceFamily'] = device_item.get('family') or ''\n    response['DeviceReachability'] = device_item.get('reachabilityStatus') or ''\n    response['DeviceReachabilityFailureReason'] = device_item.get('reachabilityFailureReason') or ''\n    # Section to set the value of Manageability and ManageErrors\n    response['DeviceManageErrors'] = ''\n    if device_item.get('managementState') == \"Managed\":\n        response['DeviceManageability'] = \"Managed\"\n        if device_item.get('collectionStatus') and device_item['collectionStatus'] != \"Managed\":\n            response['DeviceManageability'] = \"Managed (With Errors)\"\n            response['DeviceManageErrors'] = device_item['collectionStatus']\n    elif device_item.get('managementState') in [\"Unmanaged\", \"Never Managed\"]:\n        response['DeviceManageability'] = \"Unmanaged\"\n    else:\n        response['DeviceManageability'] = \"Managed (With Errors)\"\n    response['DeviceMACAddress'] = device_item.get('macAddress') or device_item.get('apEthernetMacAddress') or ''\n    response['DeviceRole'] = device_item.get('role') or 'UNKNOWN'\n    response['DeviceImageVersion'] = device_item.get('softwareVersion') or ''\n    response['DeviceUptime'] = device_item.get('upTime') or ''\n    if device_item.get('uptimeSeconds') is not None:\n        response['DeviceUptimeSeconds'] = device_item.get('uptimeSeconds')\n    else:\n        response['DeviceUptimeSeconds'] = 0\n    response['DeviceLastUpdated'] = device_item.get('lastUpdated') or ''\n    if device_item.get('lastUpdateTime') is not None:\n        response['DeviceLastUpdateTime'] = device_item.get('lastUpdateTime')\n    else:\n        response['DeviceLastUpdateTime'] = 0\n    response['DeviceSerialNumber'] = device_item.get('serialNumber') or ''\n    response['DeviceSeries'] = device_item.get('series') or ''\n    response['DevicePlatform'] = device_item.get('platformId') or ''\n    response['DeviceSupportType'] = device_item.get('deviceSupportLevel') or ''\n    response['DeviceAssociatedWLCIP'] = device_item.get('associatedWlcIp') or ''\n    return response\n\ndef get_advisories_summary(dnac):\n    \"\"\"\n    This function will retrieve the advisories summary\n    :param dnac: Cisco DNAC SDK api\n    :return: simplified advisories summary response\n    \"\"\"\n    advisories_summary = dnac.security_advisories.get_advisories_summary()\n    responses = []\n    if advisories_summary and advisories_summary.response:\n        for category in advisories_summary.response:\n            for subcategory in advisories_summary.response[category]:\n                responses.append({'Summary': 'True', 'Category': category, 'SubCategory': subcategory, 'Amount': int(advisories_summary.response[category][subcategory])})\n    return responses\n\ndef get_devices_per_advisory(dnac):\n    \"\"\"\n    This function will retrieve the advisories data and devices data as necessary\n    :param dnac: Cisco DNAC SDK api\n    :return: simplified advisories and devices response\n    \"\"\"\n    advisories_list = dnac.security_advisories.get_advisories_list()\n    responses = []\n    devices_retrieved = {}\n    if advisories_list and advisories_list.response:\n        for advisories_item in advisories_list.response:\n            response = {}\n            response['AdvisoryID'] = advisories_item.get('advisoryId') or ''\n            response['AdvisoryDeviceCount'] = advisories_item.get('deviceCount') or 0\n            # response['AdvisoryCves'] = advisories_item.get('cves') or []\n            response['AdvisoryCvesStr'] = ', '.join(advisories_item.get('cves')) or ''\n            response['AdvisoryPublicationUrl'] = advisories_item.get('publicationUrl') or ''\n            response['AdvisorySir'] = advisories_item.get('sir') or ''\n            response['AdvisoryDetectionType'] = advisories_item.get('detectionType') or ''\n            response['AdvisoryDefaultDetectionType'] = advisories_item.get('defaultDetectionType') or ''\n            if response['AdvisoryID']:\n                advisory_device = dnac.security_advisories.get_devices_per_advisory(response['AdvisoryID'])\n                if advisory_device and advisory_device.response:\n                    for device_id in advisory_device.response:\n                        # Manage device info ...\n                        device_info = {}\n                        # ... if already present, reuse\n                        if devices_retrieved.get(device_id):\n                            device_info = dict(devices_retrieved[device_id])\n                        else:  # ... if not retrieve and save it\n                            device_info = dnac.devices.get_device_by_id(id=device_id)\n                            devices_retrieved[device_id] = device_info\n                        if isinstance(device_info, dict) and device_info.get('response'):\n                            response_device = dict(response)\n                            response_device.update(get_important_device_values(device_info['response']))\n                            response_device.update({'Summary': 'False'})\n                            responses.append(response_device)\n            else:\n                responses.append(response)\n    return responses\n\ndef is_different(state, item):\n    if not isinstance(state, dict):\n        return True\n    if not isinstance(item, dict):\n        return True\n    keys = set(state.keys())\n    keys = keys.union(set(item.keys()))\n    properties = list(keys)\n    for property in properties:\n        if state.get(property) != item.get(property):\n            return True\n    return False\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    cisco_dna_center_host = definition.parameters.get('cisco_dna_center_host', None)\n    cisco_dna_center_account = definition.parameters.get('cisco_dna_center_account', None)\n    pass\n\ndef collect_events(helper, ew):\n    opt_cisco_dna_center_host = helper.get_arg('cisco_dna_center_host')\n    opt_cisco_dna_center_account = helper.get_arg('cisco_dna_center_account')\n\n    account_username = opt_cisco_dna_center_account.get(\"username\", None)\n    account_password = opt_cisco_dna_center_account.get(\"password\", None)\n    account_name = opt_cisco_dna_center_account.get(\"name\", None)\n    current_version = \"2.2.3.3\"\n    current_verify = False\n    current_debug = False\n\n    # use default input_interval\n    input_interval = 900\n    try:\n        input_interval = int(helper.get_arg(\"interval\"))\n    except ValueError as e:\n        input_interval = 900\n\n    dnac = api.DNACenterAPI(\n        username=account_username,\n        password=account_password,\n        base_url=opt_cisco_dna_center_host,\n        version=current_version,\n        verify=current_verify,\n        debug=current_debug)\n\n    # get the security advisories details and devices data as necessary\n    r_json = []\n    security_advisories = []\n    advisories_summary = []\n    try:\n        security_advisories = get_devices_per_advisory(dnac)\n    except Exception as e:\n        import traceback\n        stack = traceback.format_exc()\n        helper.log_error(stack)\n\n    for item in security_advisories:\n        key = \"{0}_{1}_{2}\".format(opt_cisco_dna_center_host, item.get('AdvisoryID') or \"NA\", item.get('DeviceIpAddress') or \"NA\")\n        state = helper.get_check_point(key)\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        if state is None:\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        elif is_different(state, item):\n            helper.save_check_point(key, item)\n            r_json.append(item)\n        # helper.delete_check_point(key)\n\n    try:\n        advisories_summary = get_advisories_summary(dnac)\n    except Exception as e:\n        import traceback\n        stack = traceback.format_exc()\n        helper.log_error(stack)\n\n    for item in advisories_summary:\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        r_json.append(item)\n\n    # To create a splunk event\n    event = helper.new_event(json.dumps(r_json), time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    ew.write_event(event)\n", "customized_options": [{"name": "cisco_dna_center_host", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "value": "account0"}], "uuid": "5c46e5e809aa4d779759b3d84dd70b22"}, {"index": "default", "sourcetype": "cisco:dnac:sensordevice", "interval": "900", "use_external_validation": true, "streaming_mode_xml": true, "name": "cisco_dnac_sensordevice", "title": "cisco_dnac_sensordevice", "description": "", "type": "customized", "parameters": [{"required": true, "name": "cisco_dna_center_host", "label": "Cisco DNA Center Host", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": ""}, {"required": true, "name": "cisco_dna_center_account", "label": "Cisco DNA Center Account", "default_value": "", "placeholder": "", "help_string": "", "possible_values": [], "type": "global_account", "format_type": "global_account", "value": ""}], "data_inputs_options": [{"type": "customized_var", "name": "cisco_dna_center_host", "title": "Cisco DNA Center Host", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "cisco_dna_center_account", "title": "Cisco DNA Center Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport json\nimport sys\nimport time\nimport datetime\n\nimport cisco_dnac_api as api\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef get_sensors(dnac):\n    \"\"\"\n    This function will retrieve the sensor details\n    :param dnac: Cisco DNAC SDK api\n    :return: sensor details\n    \"\"\"\n    responses = []\n    sensor_response = dnac.sensors.sensors()\n    if sensor_response and sensor_response.response:\n        for sensor_item in sensor_response.response:\n            sensor_item_new = dict(sensor_item)\n            if sensor_item_new.get('sshConfig'):\n                sensor_item_new['sshState'] = sensor_item_new['sshConfig'].get('sshState')\n                sensor_item_new['sshUserName'] = sensor_item_new['sshConfig'].get('sshUserName')\n                sensor_item_new['sshPassword'] = sensor_item_new['sshConfig'].get('sshPassword')\n                sensor_item_new['enablePassword'] = sensor_item_new['sshConfig'].get('enablePassword')\n            sensor_item_new.pop(\"sshConfig\", None)\n            if sensor_item_new.get('isLEDEnabled') is not None:\n                sensor_item_new['isLEDEnabled'] = str(sensor_item_new['isLEDEnabled'])\n            responses.append(sensor_item_new)\n    return responses\n\ndef is_different(state, item):\n    if not isinstance(state, dict):\n        return True\n    if not isinstance(item, dict):\n        return True\n    keys = set(state.keys())\n    keys = keys.union(set(item.keys()))\n    properties = list(keys)\n    for property in properties:\n        if state.get(property) != item.get(property):\n            return True\n    return False\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    cisco_dna_center_host = definition.parameters.get('cisco_dna_center_host', None)\n    cisco_dna_center_account = definition.parameters.get('cisco_dna_center_account', None)\n    pass\n\ndef collect_events(helper, ew):\n    opt_cisco_dna_center_host = helper.get_arg('cisco_dna_center_host')\n    opt_cisco_dna_center_account = helper.get_arg('cisco_dna_center_account')\n\n    account_username = opt_cisco_dna_center_account.get(\"username\", None)\n    account_password = opt_cisco_dna_center_account.get(\"password\", None)\n    account_name = opt_cisco_dna_center_account.get(\"name\", None)\n    current_version = \"2.2.3.3\"\n    current_verify = False\n    current_debug = False\n\n    dnac = api.DNACenterAPI(\n        username=account_username,\n        password=account_password,\n        base_url=opt_cisco_dna_center_host,\n        version=current_version,\n        verify=current_verify,\n        debug=current_debug)\n\n\n    r_json = []\n\n    # get the sensor details\n    overall_sensors = get_sensors(dnac)\n\n    for item in overall_sensors:\n        item[\"cisco_dnac_host\"] = opt_cisco_dna_center_host\n        r_json.append(item)\n\n    # To create a splunk event\n    event = helper.new_event(json.dumps(r_json), time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    ew.write_event(event)\n", "customized_options": [{"name": "cisco_dna_center_host", "value": "https://sandboxdnac.cisco.com"}, {"name": "cisco_dna_center_account", "value": "account0"}], "uuid": "07ad3b805def4ebaa6dd0b6619e01cba"}]}, "field_extraction_builder": {"cisco:dnac:clienthealth": {"data_format": "unstructured_data"}, "cisco:dnac:compliance": {"data_format": "json"}, "cisco:dnac:devicehealth": {"data_format": "json"}, "cisco:dnac:fabricdevice": {"data_format": "json"}, "cisco:dnac:fabricsite": {"data_format": "json"}, "cisco:dnac:image": {"data_format": "json"}, "cisco:dnac:networkhealth": {"data_format": "json"}}, "global_settings_builder": {"global_settings": {"log_settings": {"log_level": "DEBUG"}, "credential_settings": []}}, "sourcetype_builder": {"cisco:dnac:clienthealth": {"metadata": {"event_count": 0, "data_input_name": "cisco_dnac_clienthealth", "extractions_count": 0, "cims_count": 0}}, "cisco:dnac:compliance": {"metadata": {"event_count": 0, "data_input_name": "cisco_dnac_compliance", "extractions_count": 0, "cims_count": 0}}, "cisco:dnac:devicehealth": {"metadata": {"event_count": 0, "data_input_name": "cisco_dnac_devicehealth", "extractions_count": 0, "cims_count": 0}}, "cisco:dnac:fabricdevice": {"metadata": {"event_count": 0, "data_input_name": "cisco_dnac_fabricdevice", "extractions_count": 0, "cims_count": 0}}, "cisco:dnac:fabricsite": {"metadata": {"event_count": 0, "data_input_name": "cisco_dnac_fabricsite", "extractions_count": 0, "cims_count": 0}}, "cisco:dnac:image": {"metadata": {"event_count": 0, "data_input_name": "cisco_dnac_image", "extractions_count": 0, "cims_count": 0}}, "cisco:dnac:issue": {"metadata": {"event_count": 0, "data_input_name": "cisco_dnac_issue", "extractions_count": 0, "cims_count": 0}}, "cisco:dnac:networkhealth": {"metadata": {"event_count": 0, "data_input_name": "cisco_dnac_networkhealth", "extractions_count": 0, "cims_count": 0}}, "cisco:dnac:securityadvisory": {"metadata": {"event_count": 0, "data_input_name": "cisco_dnac_securityadvisory", "extractions_count": 0, "cims_count": 0}}, "cisco:dnac:sensordevice": {"metadata": {"event_count": 0, "data_input_name": "cisco_dnac_sensordevice", "extractions_count": 0, "cims_count": 0}}}, "validation": {"validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"], "status": "job_finished", "validation_id": "v_1649188616_66", "progress": 1.0}}